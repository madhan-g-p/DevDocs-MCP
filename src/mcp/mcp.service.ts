import { Injectable, OnModuleInit } from '@nestjs/common';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
import { z } from 'zod';
import { SearchTool } from '../tools/search.tool';
import { ExplainTool } from '../tools/explain.tool';
import { RelatedTool } from '../tools/related.tool';
import { IngestionTool } from '../tools/ingestion.tool';
import { ProjectTool } from '../tools/project.tool';

@Injectable()
export class McpService implements OnModuleInit {
  private server: McpServer;
  private sseTransports: Map<string, SSEServerTransport> = new Map();

  constructor(
    private readonly searchTool: SearchTool,
    private readonly explainTool: ExplainTool,
    private readonly relatedTool: RelatedTool,
    private readonly ingestionTool: IngestionTool,
    private readonly projectTool: ProjectTool,
  ) {
    this.server = new McpServer({
      name: 'devdocs-mcp-server',
      version: '0.1.0',
    });
  }

  async onModuleInit() {
    this.setupTools();
  }

  async initializeStdio() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.log('DevDocs MCP Server running on stdio');
  }

  async handleSseConnection(res: any) {
    const transport = new SSEServerTransport('/mcp/messages', res);
    await this.server.connect(transport);
    
    // The sessionId is generated by the transport once connected
    const sessionId = transport.sessionId;
    if (sessionId) {
      this.sseTransports.set(sessionId, transport);
      
      res.on('close', () => {
        this.sseTransports.delete(sessionId);
      });
    }
  }

  async handleSseMessage(sessionId: string, body: any, res: any) {
    const transport = this.sseTransports.get(sessionId);
    if (!transport) {
      res.status(404).send('Session not found');
      return;
    }
    await transport.handlePostMessage(body, res);
  }

  private setupTools() {
    // 1. Search Tool
    this.server.registerTool(
      'search',
      {
        description: 'Search documentation entries based on a query string. Supports fuzzy matching and project context boosting.',
        inputSchema: z.object({
          query: z.string().describe('The search query (e.g., "react hooks", "python list")'),
          limit: z.number().optional().describe('Maximum number of results to return (default 5)'),
          projectId: z.string().optional().describe('Optional project ID to prioritize documentation relevant to project dependencies'),
        })
      },
      async (args) => {
        const result = await this.searchTool.execute(args);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }],
        };
      }
    );

    // 2. Explain Tool
    this.server.registerTool(
      'explain',
      {
        description: 'Get the detailed content/documentation for a specific entry ID.',
        inputSchema: z.object({
          docId: z.string().describe('The unique ID of the documentation entry (returned from search)'),
        })
      },
      async (args) => {
        const result = await this.explainTool.execute(args);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }],
        };
      }
    );

    // 3. Related Tool
    this.server.registerTool(
      'related',
      {
        description: 'Get related documentation entries for a specific doc ID.',
        inputSchema: z.object({
          docId: z.string().describe('The unique ID of the documentation entry'),
        })
      },
      async (args) => {
        const result = await this.relatedTool.execute(args);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }],
        };
      }
    );

    // 4. Ingest Tool
    this.server.registerTool(
      'ingest',
      {
        description: 'Ingest or sync documentation for a set of project dependencies.',
        inputSchema: z.object({
          dependencies: z.record(z.string(), z.string()).describe('A map of package names to versions (e.g., {"react": "18.2.0"})'),
          devdocsBase: z.string().optional().describe('Optional custom path to store/load DevDocs data'),
        })
      },
      async (args) => {
        const result = await this.ingestionTool.execute(args);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }],
        };
      }
    );

    // 5. Setup Project Tool
    this.server.registerTool(
      'setup_project',
      {
        description: 'Configure and save project context (dependencies and path) in the local database.',
        inputSchema: z.object({
          name: z.string().describe('Name of the project'),
          path: z.string().describe('Absolute path to the project root'),
          dependencies: z.record(z.string(), z.string()).describe('Project dependencies (e.g., from package.json)'),
          ecosystem: z.string().optional().describe('The package ecosystem (e.g., "npm", "pnpm", "pip", "cargo"). Defaults to "npm".'),
        })
      },
      async (args) => {
        const result = await this.projectTool.execute(args);
        return {
          content: [{ type: 'text', text: JSON.stringify(result, null, 2) }],
        };
      }
    );
  }
}
